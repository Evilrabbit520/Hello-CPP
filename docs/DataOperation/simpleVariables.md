---
comments: true
---

# 3.1 简单变量

当我们编写程序时，通常需要存储一些信息，这些信息有的被临时存储在内存中，有的则长期保存在硬盘等存储设备中。在程序运行期间，变量主要被存储在内存[^1]中，本章我们将主要讨论存储在内存中的数据（即变量），的相关内容。把数据存储在计算机中，程序必须明白 3 个必要的特征：

- 数据将被存储在哪里
- 要以何种类型存储数据
- 要存储什么值（内容）

通过之前的“程序代码”范例，大家应该可以看到我们使用的声明中，类型描述了信息的类型并且通过特殊的字母组合（即单词）描述了其值的**变量名称**。例如程序代码2-2中使用了

``` C++
int age;
age = 18;
```

这些语句告诉程序，他正在存储 `int` 型整数，并使用 age 来表示 该整数的值（这里是 18 ）。实际上这里没有给出注释，但大家都可以明白 age 代表年龄并且年龄是 18，这便是本章下一小节即将提到的一个优秀的变量名的重要性。

程序会找到一块能够存储 `int` 型整数的内容，将所占用的内存（存储）单元标记为 age，并将 18 复制到该内存单元中。这些语句执行后，我们任何人不会知道这个值被存储在内存的什么位置，但我们的程序替我们记录了存储的信息。我们可以使用 `&` 操作符进行检索 age 在内存中的地址。在后续章节，我们会介绍指针的相关操作，届时我们会详细介绍这个操作符。

## 3.1.1 变量名

!!! tip inline end "我们强烈建议"

    选择命名时要考虑代码的可读性和可维护性，尽量让其他开发者能够通过变量名快速理解其代表的含义。

前面我们说到，我们使用的 age 变量名，在没有任何提示的情况下，大多数人都可以明白 age 变量所代表的含义，这就是本小节我们要说的，**C++ 提倡使用有一定含义的变量名。**如果变量表示其他的含义，例如：灯光强度（Light intensity）应将其命名为 lightIntensity 或 light_intensity，尽量避免将其命名为 x 或 gq 等易造成混淆的名称。如果将其命名为 li 在特定的、不会引起混淆的代码环境中，可以使用简洁的缩写，但不太推荐在大型项目中单独使用这种极短的缩写，容易引起歧义。

!!! warning "C++ 必须遵守几个简单的命名规则"

    - 在名称中智能使用字母、数字和下划线（_）；
    - 名称中的第一个字符不能是数字；
    - 不能将 C++ 中的关键字用于变量名称；
    - C++ 严格区分大小写字符[^2]；
    - C++ 对于变量名称的长度没有限制，名称中所有的字符都有意义；
    - 以两个下划线和大写字母开头的名称被保留给编译器及其使用的资源所使用，以一个下划线开头的了名称被保留给实现，用于全局[^3]标识符。

“C++ 必须遵守几个简单的命名规则”中最后一点与前几点有所不同。C++ 标准规定，以两个下划线开头且紧跟一个大写字母的名称（例如__A、__BIG_CONSTANT等）是保留给编译器及其使用的资源所使用的。这意味着我们不应该在自己的代码中使用这样的名称，否则可能会导致不可预测的结果，因为编译器可能在不同的阶段使用这些特定的名称来实现其内部的功能，或者与特定的平台相关的实现相关联。如果开发者使用了这些保留名称，可能会与编译器的行为产生冲突，导致编译错误、链接错误或者程序在运行时出现奇怪的行为。

以一个下划线开头的名称（例如_myVariable、_globalFunction等）在 C++ 中也有特殊的含义。它们被保留给实现，通常用于全局标识符。这意味着在全局作用域中，我们应该避免使用以单个下划线开头的名称作为自己定义的变量、函数或其他标识符的名称。这样的保留可以确保编译器和链接器在处理程序时不会与开发者定义的名称产生冲突，同时也为实现特定的平台相关功能或编译器内部的实现提供了一定的灵活性。

总之，如果使用我们将不知道会发生什么，但遵循这些命名规则可以避免与编译器和实现相关的名称冲突，提高程序的可移植性和稳定性。

下面是一些 C++ 中有效和无效的名称：

有效的：
- myVariable：由字母开头，后续是字母、数字和下划线的组合，是典型的有效变量名；
- _myVariable1：以单个下划线开头，是有效的，但一般不建议这么用，因为它被保留给实现（虽然通常情况下使用也不会有大问题）；
- myFunction：有效的函数名；
- MyClass：有效的类名；
- inputStream：有明确意义的名称，很常见且有效。

无效的：

- 1myVariable：以数字开头是无效的；
- my Variable：包含空格是无效的；
- my@Variable：包含特殊字符 @ 是无效的；
- int：这是 C++ 的关键字，不能作为标识符名称；
- class：同样是关键字，不能用作名称。

如果想使用两个及以上单词组成一个名称，通常的做法是用下划线将单词分开，例如：my_variable 或者从第二个单词开始将每个单词的第一个首字母大写（即小驼峰命名法），例如：myVariable。C 和 C++ 开发者更倾向于按照 C 语言的风格使用下划线，而 Java 程序员可能更偏向于使用小驼峰命名法。这两种形式都很容易将单词区分开。

!!! tip "tishi "

    在 C++ 中，对于类名一般使用大驼峰命名法（即每个单词首字母都大写，如 MyClass）。
    
    此外，还有一些常见的命名约定，比如：
    
    - 常量通常使用全大写字母，单词之间用下划线分隔，例如MAX_VALUE。
    - 命名空间通常采用小写字母且可能使用下划线来分隔单词，如my_namespace。
    
    **总的来说，虽然没有严格的规定，但遵循一定的命名约定可以提高代码的可读性和可维护性。**

## 3.1.2 整型

我们都知道，整数有无数个，但如果将无限大的整数也包括进来（尽管它确实属于整数）计算机就不可能用有限的内存来表示所有的整数。因此，我们只能表示所有整数的一个子集。C++ 提供多个整数类型，以便能根据具体要求选择使用最合适的整数类型。

C++ 基本整数类型分别有以下几种：

1. char：
    - 通常是 1 个字节大小，可以表示字符，也可以作为小范围的整数类型使用。有符号的 `char` 类型范围通常是 - 128 到 127，无符号的 `char` 类型范围是 0 到 255。
2. short（短整型）：
    - 一般为 2 个字节大小，具体大小和范围取决于编译器和平台。有符号短整型的范围通常在 - 32768 到 32767 之间。
3. int（整型）：
    - 通常是 4 个字节大小。有符号整数范围通常在 - 2147483648 到 2147483647 之间。是最常用的整数类型之一。
4. long（长整型）：
   - 在不同的平台上大小可能不同，通常至少为 4 个字节。有符号长整型的范围通常比有符号整型更大。
5. long long（长长整型）[^4]：
   - C++11 新增的类型，通常为 8 个字节大小，提供更大范围的整数表示。有符号长长整型的范围通常非常大。

!!! note "位与字节的概念"

    在计算机中，位（bit）和字节（byte）是重要的存储单位概念。

    **位（bit）**是二进制数据中的最小单位，它的值只有 0 和 1 两种状态。每一位代表一个二进制数字。计算机中的所有数据都是以二进制形式存储和处理的，位用于表示单个的二进制数字，多个位组合在一起可以表示不同的数值、字符或指令。
    
    例如：

    - 在一个 8 位的二进制数中，每一位都可以是 0 或 1，通过不同的位组合可以表示 256 种不同的数值。

    **字节（byte）**是计算机存储容量的基本单位。1 字节等于 8 位。通常用大写的“B”表示字节。字节用于衡量计算机存储容量和数据传输量。在存储方面，一个字符通常占用一个字节的存储空间。例如，在 ASCII 编码中，一个英文字母、数字或标点符号占用 1 个字节。而在 Unicode 编码中，一个字符可能占用多个字节。在数据传输方面，网络带宽通常以字节每秒（B/s）为单位来衡量数据传输的速度。
    
    例如：

    - 一个整数类型的数据在计算机中可能占用多个字节的存储空间。比如在 32 位系统中，一个 `int` 类型通常占用 4 个字节，也就是 32 位。
    - 一个文件的大小通常以字节为单位来表示。例如，一个 10KB 的文件，实际上是 10 * 1024 = 10240 字节。

每种整型类型都有有符号和无符号版，有符号类型可以表示正数、负数和零。例如，有符号 `int` 类型通常的取值范围是 -2147483648 到 2147483647。存储时，最高位（最左边的位）被用作符号位，0 表示正数，1 表示负数。无符号类型只能表示非负整数，即零和正数。例如，无符号 `int` 类型的取值范围通常是 0 到 4294967295。所有的位都用于存储数值，没有符号位。

有符号类型在发生溢出时，行为通常是未定义的，但在一些情况下可能会以循环的方式处理。例如，有符号  `char`  类型，如果从最大值继续增加，可能会变为最小值。无符号类型在溢出时，会以循环的方式进行处理。例如，无符号  `char`  类型从最大值继续增加会变为 0，然后继续增加。有符号类型在进行比较时，会考虑符号。例如，-1 小于 0。无符号类型在比较时只考虑数值大小。如果将一个有符号负数与无符号数比较，有符号数会被隐式转换为无符号数，可能会导致意外的结果。例如，有符号的 -1 转换为无符号数时会变成一个非常大的正数，通常比任何无符号正数都大。

有符号类型在大多数常规的算术运算和需要考虑正负情况的场景中使用，例如，表示温度的变化、计数的增减等。
无符号类型在确定数值一定是非负的时候使用，例如，表示对象的数量、数组的索引等。而在一些特定的算法中，需要利用无符号类型的循环溢出特性来实现特定的逻辑。

截至目前 C++ 共有 10 种整型类型使用。

可以像使用 `int` 一样使用这些类型来声明变量：

``` C++
short age                       //有符号短整型
int temperature                 //有符号整型
long number_of_rows             //有符号长整型
long long coordinate_values     //有符号长长整型

unsigned short age                       //无符号短整型
unsigned int temperature                 //无符号整型
unsigned long population                 //无符号长整型
unsigned long long number_of_particles   //无符号长长整型
```

当一个数值超过了其对应数据类型的取值范围时，无符号类型变量的值会从 0 重新开始计数。例如，假设 `unsigned int` 的取值范围是 0 到 4294967295，如果一个无符号整数变量的值为 4294967295，再对其加 1，它会变为 0。当有符号整数类型变量在进行算术运算（如加法、减法等）时发生溢出，结果是未定义行为。在实际运行中，可能出现奇怪的值，或者程序可能出现错误行为甚至崩溃，具体结果取决于编译器和运行环境。例如，对于有符号 8 位整数类型 `char`，如果其值为 127，再对其进行加 1 操作，结果是不确定的，可能是 -128（在一些编译器中会出现这种结果，因为最高位变为符号位，导致数值变为负数且取了最小值）。










[^1]: 内存分为不同的区域，比如栈空间、堆空间等。在程序运行过程中，局部变量通常存储在栈上，动态分配的内存通常在堆上。当程序执行完毕，操作系统会回收程序所占用的内存资源，这些内存中的数据通常会被清除。也有一些特殊情况，比如某些操作系统可能会采用一些技术来缓存部分内存内容，或者某些恶意软件可能会尝试在程序结束后从内存中窃取信息，但从正常的程序设计和运行角度来说，程序结束后，内存中的绝大部分信息会被认为是丢失的。

[^2]: C++ 是严格区分大小写的编程语言，所以不同大小写的标识符被视为不同的名称，例如：ABC 和 abc 将被认为是两个变量名称。

[^3]: 全局标识符是在程序的全局作用域中定义的名称。它可以是全局变量、全局函数、命名空间级别的实体等。

[^4]:在 C++11 标准中，引入了 long long 这种新的整数数据类型。虽然一些编译器可能已经支持 long long 作为扩展类型，但它并不是 C++ 标准所规定的类型。C++11 标准将其纳入，使其成为合法的、被标准认可的类型。